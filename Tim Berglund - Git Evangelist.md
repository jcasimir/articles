On Tuesday Tim Berglund (@tlberglund), GitHub’s Git evangelist, came to visit us at gSchool. He showed us how Git works from the inside out and helped move us past our functional knowledge of Git to take us on an adventure down the Git rabbit hole.

Tim started out with what he called a “Hipster Git Commit”, which was aptly named as it took the difficult approach to creating a simple Git repo. Tim used his intricate knowledge of Git to take us through the torturous path of hand crafting a Git. We likely all sat slack-jawed as he hand crafted the Git repository by hand. However, there was a method to his madness because learning the hard way showed us why the easy way worked at all. What he went over with the hipster version of git init is how a Git repo works by creating the hidden collection of files that are used to track the progress of the project over time. So why not start with git init, git add and git commit? The purpose of going over this in the “Hipster Git” way was to show us what really happened when we typed simple commands like git add and git commit. He wanted us to understand what he called the ‘porcelain’ of Git (which was his metaphor for the plumbing of Git) and expose us to the underlying layer to give us a greater understanding of the tools that we were already familiar with. It took away the ‘magic’ of ‘this just works’ and gave us an idea of how all the plumbing fits together.

Tim also went over the outer layer of how Git works and how it had been designed. His analogy was that Git is like an onion. The outer layer is the one that you will interact with most of the time (hopefully it won’t make you cry too much) and it has thus been created to cover the majority of normal functionality. Under this layer is the second skin of the onion (which is still a very well documented and accessible layer) that you can use to work on more difficult Git tasks. Tim also told us how the outer layer of Git is actually created in terms of the second layer of Git. I thought that was a very interesting way to design Git because it allows for advanced functionality while maintaining overall simplicity.

After our journey into Git Wonderland, Tim talked us through the difference between git merge and git rebase and cued us into the sometime ‘war’ that surrounds them. He showed us how git commits work, how rebasing works and what the difference between rebasing and committing is. To broad stroke it they both merge separate commits into a new commit and thus let programmers share code through a series of commits (snapshots of the project). With git merge they seem to make a few more commits to the commit log while with a rebase the same thing sorta happens but the commit log is shorter and there is an outside chance that doing this improperly will render another programmers commits worthless.

The ‘war’ that surrounds git merge vs git rebase has to do with team workflow and keeping everyone working smoothly together. The rebasing is essentially rewriting the history of a branch and pretending that it was really written later than it was. It means that there will be less commit branches hanging around making the whole project look like a train station’s rail switchyard. However, the merging approach means that different people can work on their different feature branches but it creates a messier history overall. What I got out of Tim’s talk about the war of git commit vs git rebase is that they both work when used properly and that since many teams have a very pronounced preference for one or the other, as a programmer, you should be able to use both. 

I am sure that all of my fellow gSchoolers will join me in thanking Tim Berglund for teaching us more about Git (and to GitHub for sending him over). He helped bring an in depth knowledge of a tool that we all use everyday and exposed the inner workings in a way that lets us use the tool with a better idea of how it works. 
